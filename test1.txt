import os
import json
import logging
import requests
from fastapi import FastAPI, HTTPException
from kubernetes import client, config
from openshift.dynamic import DynamicClient
from urllib3.exceptions import InsecureRequestWarning
from datetime import datetime, timedelta

# Disable SSL warnings
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

# Load Kubernetes Config
try:
    config.load_incluster_config()
except Exception as e:
    logging.error(f"Failed to load Kubernetes config: {e}")
    raise

k8s_client = client.CoreV1Api()
dyn_client = DynamicClient(client.ApiClient())

# Logging Configuration
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

app = FastAPI()

# Read ConfigMap Values
def get_configmap(namespace, name):
    try:
        cm = k8s_client.read_namespaced_config_map(name, namespace)
        return cm.data
    except Exception as e:
        logging.error(f"Failed to read ConfigMap {name}: {e}")
        raise HTTPException(status_code=500, detail=f"ConfigMap error: {e}")

# Read Secrets
def get_secret(namespace, name):
    try:
        secret = k8s_client.read_namespaced_secret(name, namespace)
        return json.loads(secret.data["credentials"])
    except Exception as e:
        logging.error(f"Failed to read Secret {name}: {e}")
        raise HTTPException(status_code=500, detail=f"Secret error: {e}")

# Fetch Inputs from ConfigMap
try:
    config_data = get_configmap("image-scanner", "configmap-properties")
    DELETE_OPERATION = config_data.get("DELETE_OPERATION", "False").lower() == "true"
    REGISTRY_URL = config_data["REGISTRY_URL"]
    CLUSTER_URL = config_data["CLUSTER_URL"]
    DEFAULT_IMAGE_NAME = config_data["DEFAULT_IMAGE_NAME"]
    RETENTION_DAYS = int(config_data["RETENTION_DAYS"])
except Exception as e:
    logging.error(f"Error loading configuration: {e}")
    raise

# Get OpenShift Secrets (Registry Credentials)
try:
    secrets = get_secret("image-scanner", "registry-secrets")
    REGISTRY_USER = secrets["user"]
    REGISTRY_PASS = secrets["password"]
except Exception as e:
    logging.error(f"Error loading secrets: {e}")
    raise

# Headers for API Authentication
auth = (REGISTRY_USER, REGISTRY_PASS)

# Function to list stale images
def list_stale_images(image_name=None, tag=None):
    try:
        cutoff_date = datetime.utcnow() - timedelta(days=RETENTION_DAYS)
        stale_images = []
        image_name = image_name or DEFAULT_IMAGE_NAME  # Use default if not provided

        if image_name:
            images = [image_name]
        else:
            response = requests.get(f"{REGISTRY_URL}/v2/_catalog", auth=auth, verify=False)
            response.raise_for_status()
            images = response.json().get("repositories", [])

        for image in images:
            tags_resp = requests.get(f"{REGISTRY_URL}/v2/{image}/tags/list", auth=auth, verify=False)
            if tags_resp.status_code != 200:
                continue

            tags = [tag] if tag else tags_resp.json().get("tags", [])

            for t in tags:
                manifest_resp = requests.get(f"{REGISTRY_URL}/v2/{image}/manifests/{t}", auth=auth, verify=False)
                if manifest_resp.status_code != 200:
                    continue

                created_date = manifest_resp.json().get("created")
                if created_date:
                    created_dt = datetime.strptime(created_date, "%Y-%m-%dT%H:%M:%SZ")
                    if created_dt < cutoff_date:
                        stale_images.append(f"{image}:{t}")

        return stale_images
    except Exception as e:
        logging.error(f"Error listing stale images: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to list stale images: {e}")

# Function to list stale pods
def list_stale_pods():
    try:
        v1_pods = dyn_client.resources.get(api_version="v1", kind="Pod")
        pods = v1_pods.get().items
        stale_pods = []

        for pod in pods:
            creation_time = pod.metadata.creationTimestamp
            if creation_time:
                created_dt = datetime.strptime(creation_time, "%Y-%m-%dT%H:%M:%SZ")
                if created_dt < datetime.utcnow() - timedelta(days=RETENTION_DAYS):
                    stale_pods.append(pod.metadata.name)

        return stale_pods
    except Exception as e:
        logging.error(f"Error listing stale pods: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to list stale pods: {e}")

# Function to list stale DeploymentConfigs
def list_stale_deploymentconfigs():
    try:
        v1_dcs = dyn_client.resources.get(api_version="apps.openshift.io/v1", kind="DeploymentConfig")
        dcs = v1_dcs.get().items
        stale_dcs = []

        for dc in dcs:
            creation_time = dc.metadata.creationTimestamp
            if creation_time:
                created_dt = datetime.strptime(creation_time, "%Y-%m-%dT%H:%M:%SZ")
                if created_dt < datetime.utcnow() - timedelta(days=RETENTION_DAYS):
                    stale_dcs.append(dc.metadata.name)

        return stale_dcs
    except Exception as e:
        logging.error(f"Error listing stale deployment configs: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to list stale deployment configs: {e}")

# Delete Image
def delete_image(image, tag):
    try:
        response = requests.delete(f"{REGISTRY_URL}/v2/{image}/manifests/{tag}", auth=auth, verify=False)
        response.raise_for_status()
        logging.info(f"Deleted image: {image}:{tag}")
    except requests.RequestException as e:
        logging.error(f"Failed to delete {image}:{tag}: {e}")

# Delete Pod
def delete_pod(pod_name):
    try:
        v1_pods = dyn_client.resources.get(api_version="v1", kind="Pod")
        v1_pods.delete(name=pod_name, namespace="image-scanner")
        logging.info(f"Deleted pod: {pod_name}")
    except Exception as e:
        logging.error(f"Failed to delete pod {pod_name}: {e}")

# Delete DeploymentConfig
def delete_deploymentconfig(dc_name):
    try:
        v1_dcs = dyn_client.resources.get(api_version="apps.openshift.io/v1", kind="DeploymentConfig")
        v1_dcs.delete(name=dc_name, namespace="image-scanner")
        logging.info(f"Deleted DeploymentConfig: {dc_name}")
    except Exception as e:
        logging.error(f"Failed to delete DeploymentConfig {dc_name}: {e}")

# FastAPI Route for Scan & Delete
@app.get("/scan-and-clean")
def scan_and_clean(image_name: str = None, tag: str = None):
    try:
        stale_images = list_stale_images(image_name, tag)
        stale_pods = list_stale_pods()
        stale_dcs = list_stale_deploymentconfigs()

        if DELETE_OPERATION:
            for img in stale_images:
                img_name, img_tag = img.split(":")
                delete_image(img_name, img_tag)

            for pod in stale_pods:
                delete_pod(pod)

            for dc in stale_dcs:
                delete_deploymentconfig(dc)

        return {
            "cluster_url": CLUSTER_URL,
            "stale_images": stale_images,
            "stale_pods": stale_pods,
            "stale_deploymentconfigs": stale_dcs,
            "delete_operation": DELETE_OPERATION
        }
    except Exception as e:
        logging.error(f"Unexpected error in scan-and-clean: {e}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")
