To target specific images within a namespace for cleanup, you can use OpenShift commands or API calls that allow filtering based on image names, labels, or other attributes. Here's how to implement this with oc CLI, Python, and Shell scripts.

1. Pruning Specific Images Using oc CLI
You can prune specific images in a namespace by filtering with oc adm prune images options or by explicitly deleting specific image streams or image tags.

Steps:
List all images in the namespace to identify the ones you want to prune:

bash
oc get is -n <namespace>
Delete specific image streams or image tags:

bash
# Delete an image stream
oc delete is <image-stream-name> -n <namespace>

# Delete a specific image tag
oc tag <namespace>/<image-stream>:<tag> -d
To prune unused images that match specific criteria, use:

bash
oc adm prune images --confirm --keep-tag-revisions=1 --keep-younger-than=15d --namespace=<namespace>
2. Pruning Specific Images with a Shell Script
You can automate the deletion of specific images using a shell script by filtering image streams based on their name or labels.

Example Script:
bash

#!/bin/bash

NAMESPACE="your-namespace"
TARGET_IMAGE="target-image-name"

# Log in to OpenShift
oc login <OpenShift-Cluster-URL> --token=<your-token>

# Fetch and delete specific image streams
echo "Fetching image streams in namespace: $NAMESPACE"
IMAGE_STREAMS=$(oc get is -n $NAMESPACE -o jsonpath='{.items[*].metadata.name}')

for IMAGE in $IMAGE_STREAMS; do
    if [[ "$IMAGE" == "$TARGET_IMAGE" ]]; then
        echo "Deleting image stream: $IMAGE"
        oc delete is $IMAGE -n $NAMESPACE
    fi
done

echo "Cleanup completed for images matching: $TARGET_IMAGE"
3. Pruning Specific Images with Python
Using the oc CLI or OpenShift's REST API, you can programmatically delete specific images.

Using oc CLI in Python:
python

import subprocess

NAMESPACE = "your-namespace"
TARGET_IMAGE = "target-image-name"

def run_oc_command(command):
    """Run an oc command and return the output."""
    try:
        result = subprocess.run(command, shell=True, check=True, stdout=subprocess.PIPE)
        return result.stdout.decode('utf-8')
    except subprocess.CalledProcessError as e:
        print(f"Command failed: {e}")
        return None

def delete_specific_image(namespace, image_name):
    """Delete a specific image stream."""
    command = f"oc delete is {image_name} -n {namespace}"
    print(f"Deleting image: {image_name} in namespace: {namespace}")
    run_oc_command(command)

def main():
    # Log in to OpenShift
    login_command = "oc login <OpenShift-Cluster-URL> --token=<your-token>"
    run_oc_command(login_command)

    # Get all image streams in the namespace
    command = f"oc get is -n {NAMESPACE} -o jsonpath='{{.items[*].metadata.name}}'"
    image_streams = run_oc_command(command).split()

    for image in image_streams:
        if image == TARGET_IMAGE:
            delete_specific_image(NAMESPACE, TARGET_IMAGE)

if __name__ == "__main__":
    main()
4. Pruning Specific Images Using OpenShift REST API
If you want more control, you can interact directly with OpenShift's REST API.

Steps:
List Image Streams: Use the API endpoint to list image streams in a namespace:

bash

curl -H "Authorization: Bearer <your-token>" \
     -X GET "https://<OpenShift-Cluster-URL>/apis/image.openshift.io/v1/namespaces/<namespace>/imagestreams"
Delete Specific Image Stream: Identify the image stream name and delete it:

bash

curl -H "Authorization: Bearer <your-token>" \
     -X DELETE "https://<OpenShift-Cluster-URL>/apis/image.openshift.io/v1/namespaces/<namespace>/imagestreams/<image-name>"
Python REST API Example:
python

import requests

API_URL = "https://<OpenShift-Cluster-URL>/apis/image.openshift.io/v1/namespaces/your-namespace/imagestreams"
TOKEN = "<your-token>"
HEADERS = {"Authorization": f"Bearer {TOKEN}"}

def get_image_streams():
    response = requests.get(API_URL, headers=HEADERS)
    if response.status_code == 200:
        return response.json()["items"]
    else:
        print(f"Failed to fetch image streams: {response.text}")
        return []

def delete_image_stream(image_name):
    url = f"{API_URL}/{image_name}"
    response = requests.delete(url, headers=HEADERS)
    if response.status_code == 200:
        print(f"Deleted image stream: {image_name}")
    else:
        print(f"Failed to delete image stream {image_name}: {response.text}")

def main():
    image_streams = get_image_streams()
    for image in image_streams:
        if image["metadata"]["name"] == "target-image-name":
            delete_image_stream(image["metadata"]["name"])

if __name__ == "__main__":
    main()
Recommendations
Use oc CLI for simple, manual deletions or scripted tasks in small environments.
Use Shell scripting for automated tasks where CLI commands suffice and the environment is straightforward.
Use Python scripts for more complex tasks requiring logic, filtering, or interaction with external systems.
Use the OpenShift REST API for granular control and integration with custom automation platforms.
Schedule these scripts using tools like Cron, Jenkins, or other orchestration tools for periodic execution.
Pros and Cons for Namespace-Specific Cleanup
Method	Pros	Cons
oc CLI	Easy to use, minimal setup, namespace-specific commands.	Requires manual intervention or additional scripting for automation.
Shell Scripts	Simple automation, can run from external systems.	Limited logic for advanced filtering or custom operations.
Python Scripts	Flexible, supports complex logic and integration.	Requires Python setup and libraries like requests for REST API usage.
REST API	Granular control, integrates with custom workflows and monitoring tools.	Higher complexity, requires API authentication and knowledge.
By combining these methods, you can effectively clean up specific images within namespaces based on your organization's policies and requirements.
