# app.py (FastAPI application with logging, OpenShift namespace aware, ocplogin and Artifactory AQL)
from fastapi import FastAPI, HTTPException
import datetime
import requests
import urllib3
from openshift.dynamic import DynamicClient
import os
import yaml
from kubernetes import config, client
import base64
import logging
import uvicorn
import subprocess
import json
from tabulate import tabulate
from dateutil import parser, tz

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

app = FastAPI()

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# ... (rest of your functions: get_namespace, load_config_from_configmap, load_secrets_from_secret, get_openshift_client, get_registry_token, execute_artifactory_aql_query_manifest_list)

def remove_image_tag_manifest(registry_url, image_name, tag, registry_token):
    """Removes an image tag, logging if the image is not found."""
    results = execute_artifactory_aql_query_manifest_list(f"https://{registry_url}", image_name.split('/')[0], '/'.join(image_name.split('/')[1:]), tag, registry_token)
    if results:
        artifactory_url = f"https://{registry_url}/artifactory/api/search/aql"
        headers = {"Authorization": f"Bearer {registry_token}", "Content-Type": "text/plain"}
        aql_query = f"""items.find({{"repo":"{image_name.split('/')[0]}","path":"{'/'.join(image_name.split('/')[1:])}","name":"{tag}"}})"""
        response = requests.post(artifactory_url, headers=headers, data=aql_query, verify=False)
        try:
            response.raise_for_status()
            results = response.json().get("results", [])
            if results:
                for result in results:
                    delete_url = f"https://{registry_url}/artifactory/{result['repo']}/{result['path']}/{result['name']}"
                    delete_response = requests.delete(delete_url, headers={"Authorization": f"Bearer {registry_token}"}, verify=False)
                    delete_response.raise_for_status()
                    logger.info(f"Removed image tag: {delete_url}")
            else:
                logger.warning(f"Image tag not found in Artifactory: {tag}")
        except requests.exceptions.RequestException as e:
            logger.error(f"Error deleting image tag: {e}")
            raise HTTPException(status_code=500, detail=f"Error deleting image tag: {e}")

    else:
        logger.warning(f"Manifest list not found, skipping delete tag {tag}")
        

def get_pods(client, namespace):
    try:
        pods = client.resources.get(api_version='v1', kind='Pod').get(namespace=namespace).items
        if not pods:
            logger.warning(f"No pods found in namespace {namespace}.")
        return pods
    except Exception as e:
        logger.error(f"Error retrieving pods: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving pods: {e}")

def remove_pod(client, namespace, pod_name):
    try:
        client.resources.get(api_version='v1', kind='Pod').delete(namespace=namespace, name=pod_name)
        logger.info(f"Deleted pod {pod_name} in namespace {namespace}.")
    except Exception as e:
        logger.error(f"Error removing pod: {e}")
        raise HTTPException(status_code=500, detail=f"Error removing pod: {e}")

def get_deployment_configs(client, namespace):
    try:
        deployment_configs = client.resources.get(api_version='apps.openshift.io/v1', kind='DeploymentConfig').get(namespace=namespace).items
        if not deployment_configs:
            logger.warning(f"No deployment configs found in namespace {namespace}.")
        return deployment_configs
    except Exception as e:
        logger.error(f"Error retrieving deployment configs: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving deployment configs: {e}")

def remove_deployment_config(client, namespace, deployment_config_name):
    try:
        client.resources.get(api_version='apps.openshift.io/v1', kind='DeploymentConfig').delete(namespace=namespace, name=deployment_config_name)
        logger.info(f"Deleted deployment config {deployment_config_name} in namespace {namespace}.")
    except Exception as e:
        logger.error(f"Error removing deployment config: {e}")
        raise HTTPException(status_code=500, detail=f"Error removing deployment config: {e}")

def get_image_digests_with_creation_dates(registry_url, image_name, registry_token, specific_tag=None):
    try:
        registry_api_url = f"https://{registry_url}/v2/{image_name}/tags/list"
        headers = {"Authorization": f"Bearer {registry_token}"}
        response = requests.get(registry_api_url, headers=headers, verify=False)
        response.raise_for_status()
        tags_list = response.json().get("tags", [])
        if specific_tag and specific_tag not in tags_list:
            return {}

        image_digests_with_dates = {}
        image_found = False  # Add this flag
        for tag in tags_list:
            if specific_tag and tag != specific_tag:
                continue

            manifest_api_url = f"https://{registry_url}/v2/{image_name}/manifests/{tag}"
            manifest_response = requests.get(manifest_api_url, headers={"Accept": "application/vnd.docker.distribution.manifest.v2+json", "Authorization": f"Bearer {registry_token}"}, verify=False)
            manifest_response.raise_for_status()
            manifest = manifest_response.json()
            if "config" in manifest and "digest" in manifest["config"]: #check if manifest config exists.
                image_identifier = manifest["config"]["digest"]
                creation_date = get_image_creation_date(registry_url, image_name, tag, registry_token)
                if creation_date:
                    image_digests_with_dates[image_identifier] = creation_date
                    image_found = True  # Set the flag if image details are found
                else:
                    logger.warning(f"Failed to retrieve creation date for image: {image_name}:{tag}")
            else:
                logger.warning(f"Image config or digest not found in manifest for {image_name}:{tag}")
        
        if not image_found:
            logger.warning(f"No images found for {image_name} with tag {specific_tag}.") # Log if no images found

        return image_digests_with_dates

    except requests.exceptions.RequestException as e:
        logger.error(f"Error retrieving image digests and creation dates: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving image digests and creation dates: {e}")

def get_image_creation_date(registry_url, image_name, tag, registry_token):
    try:
        manifest_api_url = f"https://{registry_url}/v2/{image_name}/manifests/{tag}"
        manifest_response = requests.get(manifest_api_url, headers={"Accept": "application/vnd.docker.distribution.manifest.v2+json", "Authorization": f"Bearer {registry_token}"}, verify=False)
        manifest_response.raise_for_status()
        manifest = manifest_response.json()
        image_identifier = manifest["config"]["digest"]

        config_api_url = f"https://{registry_url}/v2/{image_name}/blobs/{image_identifier}"
        response = requests.get(config_api_url, headers={"Authorization": f"Bearer {registry_token}"}, verify=False)
        response.raise_for_status()
        config = response.json()
        created_str = config.get("config", {}).get("Created")

        if created_str and created_str.strip():
            try:
                creation_date = parser.isoparse(created_str)
                return creation_date
            except ValueError:
                logger.warning(f"Invalid ISO format for creation date: {created_str} for {registry_url}/{image_name}/{tag}")
                return None
        else:
            logger.warning(f"Creation date not found for {registry_url}/{image_name}/{tag}")
            return None

    except requests.exceptions.RequestException as e:
        logger.error(f"Error retrieving image creation date: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving image creation date: {e}")



@app.post("/clean-registry/")
def clean_registry(specific_tag: str = None, delete_operation: bool = False):
    namespace = get_namespace()
    config_map_name = os.getenv("CONFIGMAP_NAME", "registry-cleaner-config")
    secret_name = os.getenv("SECRET_NAME", "registry-cleaner-secret")

    logger.info(f"Starting registry cleaning process. Specific tag: {specific_tag}, Delete operation: {delete_operation}")

    config_data = load_config_from_configmap(namespace, config_map_name)
    secret_data = load_secrets_from_secret(namespace, secret_name)

    registry_url = config_data.get("registry_url")
    image_name = config_data.get("image_name")
    retention = config_data.get("retention", int(config_data.get("retention", 30)))
    skip_tags = [tag.strip() for tag in config_data.get("skip_tags", "").split(",") if tag.strip()]
    delete_deployments = config_data.get("delete_deployments", "false").lower() == "true"
    filter_namespace = config_data.get("filter_namespace")

    client = get_openshift_client()
    registry_token = get_registry_token(registry_url)

    image_identifiers_with_dates = get_image_digests_with_creation_dates(registry_url, image_name, registry_token, specific_tag)

    stale_images = {}
    cutoff_date = datetime.datetime.now(tz.UTC) - datetime.timedelta(days=retention)

    sorted_images = sorted(image_identifiers_with_dates.items(), key=lambda item: item[1], reverse=True)

    keep_images = []
    for image_identifier, creation_date in sorted_images:
        if creation_date is not None:
            keep_images.append(image_identifier)
    if len(keep_images) > 0:
        keep_images = [keep_images[0]]

    for image_identifier, creation_date in image_identifiers_with_dates.items():
        tag = None
        for image_tag, image_creation_date in get_image_digests_with_creation_dates(registry_url, image_name, registry_token, specific_tag).items():
            if image_creation_date == creation_date:
                tag = image_tag
                break

        if creation_date is None:
            continue
        if creation_date < cutoff_date and image_identifier not in keep_images and tag not in skip_tags:
            stale_images[image_identifier] = tag

    image_table = []
    for image_identifier, tag in stale_images.items():
        image_table.append([f"{registry_url}/{image_name}:{tag}", tag])

    deployment_configs_to_delete = []
    pods_to_delete = []

    if stale_images and delete_deployments:
        deployment_configs = get_deployment_configs(client, namespace)
        if not deployment_configs:
            logger.warning(f"No DeploymentConfigs found in namespace {namespace} during deletion check.")
        else:
            for deployment_config in deployment_configs:
                deployment_config_namespace = deployment_config.metadata.namespace
                if filter_namespace and deployment_config_namespace != filter_namespace:
                    continue
                deployment_config_name = deployment_config.metadata.name
                containers = deployment_config.spec.template.spec.containers
                for container in containers:
                    image = container.image
                    for image_identifier, tag in stale_images.items():
                        if f"{registry_url}/{image_name}:{tag}" in image:
                            deployment_configs_to_delete.append([deployment_config_namespace, deployment_config_name])

        pods = get_pods(client, namespace)
        if not pods:
            logger.warning(f"No Pods found in namespace {namespace} during deletion check.")
        else:
            for pod in pods:
                pod_namespace = pod.metadata.namespace
                if filter_namespace and pod_namespace != filter_namespace:
                    continue
                pod_name = pod.metadata.name
                containers = pod.spec.containers
                for container in containers:
                    image = container.image
                    for image_identifier, tag in stale_images.items():
                        if f"{registry_url}/{image_name}:{tag}" in image:
                            pods_to_delete.append([pod_namespace, pod_name])

        if delete_operation:
            deleted_images = []
            deleted_deployment_configs = []
            deleted_pods = []

            for image_identifier, tag in stale_images.items():
                results = execute_artifactory_aql_query_manifest_list(f"https://{registry_url}", image_name.split('/')[0], '/'.join(image_name.split('/')[1:]), tag, registry_token)
                if results:
                    remove_image_tag_manifest(registry_url, image_name, tag, registry_token)
                    deleted_images.append([f"{registry_url}/{image_name}:{tag}", tag])
                    logger.info(f"Deleted image {registry_url}/{image_name}:{tag}")
                else:
                    logger.warning(f"Image {registry_url}/{image_name}:{tag} does not exist. Skipping deletion.")

            for deployment_config_namespace, deployment_config_name in deployment_configs_to_delete:
                try:
                    remove_deployment_config(client, deployment_config_namespace, deployment_config_name)
                    deleted_deployment_configs.append([deployment_config_namespace, deployment_config_name])
                except HTTPException as e:
                    if "Not Found" in e.detail:
                        logger.warning(f"DeploymentConfig {deployment_config_name} in namespace {deployment_config_namespace} not found. Skipping deletion.")
                    else:
                        raise  # Re-raise the exception if it's not a "Not Found" error

            for item in pods_to_delete:
                if isinstance(item, (tuple, list)) and len(item) == 2:
                    pod_namespace, pod_name = item
                    try:
                        remove_pod(client, pod_namespace, pod_name)
                        deleted_pods.append([pod_namespace, pod_name])
                        logger.info(f"Deleted pod {pod_name} in namespace {pod_namespace}.")
                    except HTTPException as e:
                        if "Not Found" in e.detail:
                            logger.warning(f"Pod {pod_name} in namespace {pod_namespace} not found. Skipping deletion.")
                        else:
                            raise  # Re-raise the exception if it's not a "Not Found" error
                else:
                    logger.warning(f"Invalid item in pods_to_delete: {item}")

            logger.info("Registry cleaning process completed with deletion.")

            image_table_formatted = tabulate(deleted_images, headers=["Deleted Image", "Tag"], tablefmt="grid")
            deployment_configs_table_formatted = tabulate(deleted_deployment_configs, headers=["Deleted DeploymentConfig Namespace", "Deleted DeploymentConfig"], tablefmt="grid")
            pods_table_formatted = tabulate(deleted_pods, headers=["Deleted Pod Namespace", "Deleted Pod Name"], tablefmt="grid")
            return {
                "deleted_stale_images": image_table_formatted,
                "deleted_deployment_configs": deployment_configs_table_formatted,
                "deleted_pods": pods_table_formatted,
                "message": "Registry cleaning process completed with deletion."
            }
        else:
            logger.info("Registry cleaning process completed without deletion.")
            image_table_formatted = tabulate(image_table, headers=["Image", "Tag"], tablefmt="grid")
            deployment_configs_table_formatted = tabulate(deployment_configs_to_delete, headers=["DeploymentConfig Namespace", "DeploymentConfig"], tablefmt="grid")
            pods_table_formatted = tabulate(pods_to_delete, headers=["Pod Namespace", "Pod Name"], tablefmt="grid")
            return {
                "stale_images": image_table_formatted,
                "deployment_configs_to_delete": deployment_configs_table_formatted,
                "pods_to_delete": pods_table_formatted,
                "message": "Registry cleaning process completed without deletion."
            }
    else:
        logger.info("No stale images found, or delete not enabled.")
        return {"message": "No stale images found, or delete not enabled."}

def main():
    uvicorn.run("app:app", host="0.0.0.0", port=8000)

if __name__ == "__main__":
    main()
